<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Ball Physics</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
  }
  canvas {
    display: block;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
  // ------------------------------------------------------------
  // CONFIG â€” add your filenames and assets here
  // ------------------------------------------------------------
  const imageFiles = [
    "", "", "", "", "", "", "", "", "", "", "", "", ""
  ]; // fill with 13 png filenames (e.g. "ball1.png", etc.)

  const specialIndex = 3;        // index of the special ball (plays sound + swaps image)
  const specialNewImage = "";    // new PNG after grab (e.g. "changed.png")
  const specialSound = "";       // sound file (e.g. "sound.mp3")

  const largeIndex = 8;          // index of the large ball (different from special one)
  const NUM_BALLS = 13;
  const TARGET_IMG_SIZE = 360;
  const RESTITUTION = 0.85;
  const FRICTION_AIR = 0.995;
  const GRAVITY = 1500;

  const { Engine, Render, Runner, Bodies, Composite, Mouse, MouseConstraint, Events } = Matter;

  const engine = Engine.create();
  const world = engine.world;

  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  const ground = Bodies.rectangle(window.innerWidth/2, window.innerHeight + 50, window.innerWidth, 100, { isStatic: true });
  Composite.add(world, ground);

  let balls = [];

  function initBalls() {
    balls = [];
    const scaleFactor = window.innerWidth / 1920;

    for (let i = 0; i < NUM_BALLS; i++) {
      const isLarge = (i === largeIndex);
      const img = new Image();
      img.src = imageFiles[i] || "";
      const radius = isLarge ? TARGET_IMG_SIZE * 0.6 * scaleFactor : TARGET_IMG_SIZE * 0.4 * scaleFactor;

      const ball = Bodies.circle(
        Math.random() * window.innerWidth,
        Math.random() * window.innerHeight / 2,
        radius / 2,
        {
          restitution: RESTITUTION,
          frictionAir: 1 - FRICTION_AIR,
          render: { sprite: { texture: img.src } }
        }
      );

      ball.image = img;
      ball.radius = radius / 2;
      ball.isSpecial = (i === specialIndex);
      ball.hasChanged = false;
      balls.push(ball);
    }
    Composite.add(world, balls);
  }

  initBalls();

  const mouse = Mouse.create(canvas);
  const mouseConstraint = MouseConstraint.create(engine, {
    mouse: mouse,
    constraint: {
      stiffness: 0.2,
      render: { visible: false }
    }
  });
  Composite.add(world, mouseConstraint);

  const render = Render.create({
    engine: engine,
    canvas: canvas,
    options: {
      width: window.innerWidth,
      height: window.innerHeight,
      wireframes: false,
      background: 'transparent'
    }
  });

  Render.run(render);
  const runner = Runner.create();
  Runner.run(runner, engine);

  Events.on(engine, "afterUpdate", () => {
    for (let ball of balls) {
      if (ball.position.y - ball.radius > window.innerHeight) {
        Matter.Body.setPosition(ball, { x: Math.random() * window.innerWidth, y: -100 });
        Matter.Body.setVelocity(ball, { x: 0, y: 0 });
      }
    }
  });

  Events.on(mouseConstraint, "mousedown", (event) => {
    const mousePosition = event.mouse.position;
    for (let ball of balls) {
      const dx = ball.position.x - mousePosition.x;
      const dy = ball.position.y - mousePosition.y;
      if (Math.sqrt(dx * dx + dy * dy) <= ball.radius) {
        if (ball.isSpecial && !ball.hasChanged) {
          ball.hasChanged = true;
          if (specialSound) {
            const audio = new Audio(specialSound);
            audio.play().catch(()=>{});
          }
          if (specialNewImage) {
            ball.image.src = specialNewImage;
          }
        }
      }
    }
  });

  (function renderLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (let ball of balls) {
      const x = ball.position.x;
      const y = ball.position.y;
      const angle = ball.angle;
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);
      if (ball.image.complete && ball.image.src) {
        ctx.drawImage(ball.image, -ball.radius, -ball.radius, ball.radius * 2, ball.radius * 2);
      } else {
        ctx.beginPath();
        ctx.arc(0, 0, ball.radius, 0, Math.PI * 2);
        ctx.fillStyle = "white";
        ctx.fill();
      }
      ctx.restore();
    }
    requestAnimationFrame(renderLoop);
  })();
</script>
</body>
</html>
